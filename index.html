<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="assets/style.css"/>
    <title>Теория 17 недели (9 неделя JS). "Объекты и классы".</title>
  </head>
  <body>
    <div class="root">
      <h1>
        Кот, привет. Вот мои ответы на теоретические вопросы 17 недели (9 неделя
        JS)
      </h1>
      <ol>
            <li>
                Чем отличается класс от объекта? Приведите примеры и того, и другого,
                отличные от указанных в уроке.
                <p>
                    Ответ: класс - это тип данных, созданный пользователем. Модель
                    (шаблон) для создания объектов определенного типа,<br />
                    описывающая их структуру (поля и их начальные состояния) и
                    определяющая алгоритмы (функции или методы) для работы с этими
                    объектами.<br />
                    Объект - это экземпляр класса, обладающий описанной им структурой и
                    алгоритмами.<br />
                    Примеры: блюдо в меню ресторана - это класс. У него есть свойства:
                    название, продукты, из которых оно приготовлено, калорийность,
                    масса, <br />температура, цена. Методы: способ приготовления, способ
                    употребления блюда (напиток можно выпить, второе - съесть), вариант
                    подачи.<br />
                    Любое блюдо из этого меню - это пример конкретного объекта данного
                    класса.
                </p>
            </li>
            <li>
                <ul>
                    <li>
                        Приведите примеры объектно-ориентированного подхода в реальной
                        жизни.
                        <p>
                            Ответ: город может содержать классы Дома (высота, количество
                            этажей, основной материал для строительства, год постройки),
                            Улицы (название, ширина,<br />
                            протяженность, дорожное покрытие, количество домов), Парки
                            (название, площадь, виды растений, количество дорожек).
                        </p>
                    </li>
                    <li>
                        Приведите примеры объектно-ориентированного подхода в
                        программировании.
                        <p>
                            Ответ: статьи на новостном сайте (название, дата, текст),
                            электронный дневник пользователя (автор, дата записи, тема,
                            текст, комментарии (если это публичный дневник)),<br />
                            электронная библиотека (книги, авторы, стоимость, форматы для
                            скачивания).
                        </p>
                    </li>
                </ul>
            </li>
            <li>
                Что такое конструктор? Самостоятельно изучите и напишите, какие бывают
                виды конструкторов.
                <p>
                    Ответ: Конструктор - это специальная функция, задача которой
                    заполнить пустой объект свойствами и методами.<br />
                    Иными словами, конструктор - это функция, которая конфигурирует
                    объект для дальнейшего использования. Функции-конструкторы
                    технически являются обычными функциями. Но есть два соглашения: -
                    Имя функции-конструктора должно начинаться с большой буквы. -
                    Функция-конструктор должна выполняться только с помощью оператора
                    "new". Основной целью конструкторов – является реализовать код для
                    многократного создания однотипных объектов.<br />
                    В принципе любую функцию (кроме стрелочной) можно использовать, как
                    конструктор.<br />
                    В JavaScript есть встроенные конструкторы для собственных объектов:<br />
                    <ul>
                        <li>let x1 = new Object(); // Новый объект Object</li>
                        <li>let x2 = new String();   // Новый объект String</li> 
                        <li>let x3 = new Number(); // Новый объект Number</li>
                        <li>let x4 = new Boolean(); // Новый объект Boolean</li>
                        <li>let x5 = new Array(); // Новый объект Array</li>
                        <li>let x6 = new RegExp(); // Новый объект RegExp</li>
                        <li>let x7 = new Function(); // Новый объект Function</li>
                        <li>let x8 = new Date(); // Новый объект Date</li>
                    </ul>
                </p>
            </li>
            <li>Что выведет код? Почему именно так?<br>
                <img src="assets/img/4_question.png" alt="4 вопрос">
                <p>Ответ: в консоль попадет ninja; pomidor и site.<br>
                Функция вызывается в глобальном контексте, поэтому this ссылается на глобальный объект window, где переменной<br>
                name мы записали значение ninja. А при вызове функции через объекты obj1 и obj2 this будет указывать на соответствующий объект<br>
                и выводит соответственно его свойство name.</p>
            </li>
            <li>Чем статические свойства и методы отличаются от нестатических? В каких ситуациях они применяются?
                <p>Ответ: статические методы можно присвоить самому классу. В объявление класса они добавляются с помощью ключевого слова static.<br>
                    Обычно статические методы используются для реализации функций, принадлежащих классу целиком, вообще, и при этом не относящимся к каким-то отдельным объектам.<br>
                    Статические методы также используются в классах, относящихся к базам данных, для поиска/сохранения/удаления вхождений в базу данных.<br>
                    Статические методы могут вызываться для классов, но не для отдельных объектов.<br>
                    Статические свойства также возможны, они выглядят как свойства класса, но с static в начале. Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне класса, а не какого-то одного объекта.
                </p>
            </li>
            <li>Самостоятельно изучите, что такое геттеры и сеттеры, приведите пример класса с их использованием.
                <p>Ответ: у объекта есть есть два типа свойств: первые - свойства-данные, вторые - свойства-аксессоры. Вторые по своей сути это функции, <br>
                    которые используются для присвоения и получения значений, но во внешнем коде они выглядят как обычные свойства объекта. <br>
                    Свойства-аксесоры представлены методами: "геттер" - для чтения и "сеттер" - для записи. При литеральном объявлении
                    объекта они обозначаются get и set.
                </p>
                <p>let obj = {<br>
                    get propName() {//геттер, срабатывает при чтении obj.propName<br>
                    },<br>
                    set propName(value) {<br>
                        //сеттер, срабатывает при записи obj.propName = value<br>
                    }<br>
                };<br>
                </p>
                <p>
                   Например, у нас есть объект user со свойствами name и surname:<br>

                    let user = {<br>
                    name: "Иван",<br>
                    surname: "Симонов"<br>
                    };<br>
                </p>   
                <p>А теперь добавим свойство объекта fullName для полного имени. Чтобы не дублировать уже имеющуюся информацию, реализуем его при помощи аксессора:<br>

                    let user = {<br>
                    name: "Иван",<br>
                    surname: "Симонов",<br>

                    get fullName() {<br>
                        return `${this.name} ${this.surname}`;<br>
                    }<br>
                    };<br>

                    alert(user.fullName); // Иван Симонов<br>
                </p>
                   <p>Мы не вызываем user.fullName как функцию, а читаем как обычное свойство: геттер выполнит всю работу за кулисами.<br>
                    Можем назначить сеттер, чтобы можно было назначать значение.<br></p>
                    let user = {<br>
                        name: "Иван",<br>
                        surname: "Симонов",<br>
        
                        get fullName() {<br>
                            return `${this.name} ${this.surname}`;<br>
                        }<br>
                        set fullName(value) {<br>
                            [this.name, this.surname] = value.split(" ");<br>
                        }<br>
                    };<br>
                    Запустим fullName с другим занчением<br>
                    user.fullName = "Алиса Иванова";<br>
                    alert(user.name); // Алиса<br>
                    alert(user.surname); // Иванова<br>

                <p>В большинстве случаев используют синтаксис функций getИмяфункции/setИмяфункции. Так как функции более гибкие, <br>
                    они могут принимать несколько аргументов.
                </p>
            </li>
            <li>Что выведет код? Почему именно так?<br>
                <img src="assets/img/7_question.png" alt="7 вопрос">
                <p>Ответ: Так как оператор typeof возвращает строку, указывающую тип операнда, то в консоли будет object (а member у нас объект). </p>
            </li>
            <li>Что выведет код? Почему именно так?<br>
                <img src="assets/img/8_question.png" alt="8 вопрос">
                <p>Ответ: в консоли будет:<br>
                    Object { name: "Valera", age: 23 }<br>
                        
                    Потому что мы создали объект person со свойствами name и age. А потом создали переменную city со значением person.sity, после присвоили ей новое значение.<br>
                    На объект person это не оказало никакого влияния.
                </p>
            </li>
        </ol>
    </div>
    <script src="index.js"></script>
  </body>
</html>
